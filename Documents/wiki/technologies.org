
* Statistics
** Hipothesis test
1-alptha = confidence
alpha = 0.05 investigations
alpha = 0.01 prove quality
alpha = 0.10 stuff that has to do with humans(volatility)

populations < 30 you do a t-student test
else a Z (normality) test
*** Scores

they are used to prove if an hypothesis is right or wrong, using the alphas => 1-alpha
https://www.simplypsychology.org/z-score.html
https://www.statisticshowto.com/standardized-test-statistic/
Z-scores for normal samples
T-scores for normal samples population is less than 30
*** Parametric tests
y   ou use the scores (using the formulas)
*** non parametric tests
**** prueba del signo
    se hacen diferencias entre los datos, solo interesa el signo de la diferencia, se cuentan los positivos y negativos y se saca el z-score 
    
**** correlacion por rangos  (menor a 25 usar t student)

    se ordenan de menor a mayor, se sacan rangos usando la posicion ordenada (inicial - final)/2 de un numero repetido, si no esta repetido, entonces
    su rango es su posicion. Se sacan diferencias de los rangos de los 2 grupos y se usa la formula al final, a este resultado se le llama Rs y se sustituye
    en la formula para hallar t-student o z-score (ajustada para esta variable Rs)
    
**** Wilcoxon (menor 24 usar t-student)
  
    se usa para parejas de datos como (esposa esposo)
    
**** Man whitney (t-student si menor a 20)
las muestras no tienen que ser de mismo tamaño!
se sacan rangos igual que correlacion por rangos, luego se suman los rangos de cada muestra , quedando con los 2 valores del rango para ambas muestras

finalmente se escoje el rango mas pequeño de los 2 y se substituye en la formula para encontrar un U, luego se encuentra el z-score o t-score (modificados para usar U)
y se prueba la hipotesis

**** Kruskal watts (muestras independientes, puedens ser mas de 2)
  se juntan todos los datos de todas las muestras, se ordenan, se encuentran los rangos igual que en el correlacion por rangos
  luego de encontrar los rangos, se separan los datos como estaban y se suman los rangos totales para cada muestra, quedamos con que cada muestra tiene un rango total
  encontramos H con la formula que usa los rangos, este es el H-score, se calcula la grafica usando xi cuadrado , el error es: Xi(alpha, k-1) donde k es el numero de muestras 
el resultado de Xi dara el punto donde comienza el error

**** Xi cuadrado
  para verificar si los datos son consistentes con el modelo
  chi-square test is used to determine whether there is a statistically significant difference between the expected frequencies and the observed
  frequencies in one or more categories of a contingency table. 
  
**** Correccion de yates
 is used in certain situations when testing for independence in a contingency table.
 It aims at correcting the error introduced by assuming that the discrete probabilities of frequencies in the table
 can be approximated by a continuous distribution (chi-squared).
 In some cases, Yates's correction may adjust too far, and so its current use is limited. 
 
se utiliza Xi cuadrado para encontrar donde inicia el error, se usan las formulas para encontrar el Xi-score
 
***** a contingency table
In statistics, a contingency table (also known as a cross tabulation or crosstab) is a type of table in a matrix format that
 displays the (multivariate) frequency distribution of the variables. They are heavily used in survey research,
 business intelligence, engineering and scientific research.
   
** Anova
se debe de verificar
    1. Independencia de las variables
    2. Shapiro-wilk test (normality)
    3. bartlet test (homocedasticity)

* Machine Learning
** Types of machine learning
*** Supervised
training: when you have data and you know the output
*** Unsupervised
training: when you have data but no output (group data in clusters)
*** Reinforcement
when you give positive points to something that gets you closer to your goal/flag
** Fundamental Algorithms
*** Linear Regression
**** Analysis


1. First, linear regression needs the relationship between the independent and dependent variables to be linear (correlation).
  It is also important to check for outliers since linear regression is sensitive to outlier effects

2. Secondly, the linear regression analysis requires all variables to be multivariate normal.Secondly,
 the linear regression analysis requires all variables to be multivariate normal.
Normality can be tested with the Shapiro-Wilk test or be checked with a histogram or a Q-Q-Plot.  

    +  When the data is not normally distributed, a non-linear transformation (e.g., log-transformation) might fix this issue.

**** Correlation
is r and r2 (squared)
for example, R2 = 0.8234 means that the linear model explains 82.34% of the variance
between the 2 variables
+ Pearson
  measures correlation
+ Spearman
  measures correlation using ranks, specially for ordinal variables

the correlation is done by drawind a line of best fit

***** line of best fit
can be calculated using the least square method: https://www.youtube.com/watch?v=JvS2triCgOY

line that gets as close as possible to most points
the line of best fit is used to predict future values
*** Classification
*** Clustering
*** Hidden Markov Models


* Tensorflow
** Main components
*** Graphs
an equation definition
*** Sessions
Executes certain parts of the graph
** Tensor
generalization of vectors and matrixes in potentially higher dimensions

Each tensor represents a partially defined computation that will eventually produce a value, which means that
tensors can be executed and you can get results from them
*** Types of Tensors
all are immutable except variables
+ Variables
+ Constants
+ Placeholder
+ SparseTensor
*** Evaluating Tensors/Getting value of a tensor
to get the value of a Tensor you need to create a session, like this

with tf.Session() as sess: # creates a session using the default graph
    name_of_my_tensor.eval()  

*** Rank/Degree
the deepest level of a nested list

+ Rank 1
    rank1_tensor = tf.Variable(["Test"], tf.string) 
+ Rank 2
    rank2_tensor = tf.Variable([["test", "ok"], ["test", "yes"]], tf.string)
    
tf.rank(rank2_tensor)
<tf.Tensor: shape=(), dtype=int32, numpy=2>

the numpy=2 means is of rank 2
*** example
string = tf.Variable("this is a string", tf.string) 
number = tf.Variable(324, tf.int16)
floating = tf.Variable(3.567, tf.float64)
*** Shape
all tensors have the attribute .shape
represents the number of items that exist in each dimension

rank2_tensor = tf.Variable([["test", "ok", "hey"], ["test", "yes", "why"]], tf.string)
+ rank2_tensor.shape 

  Tensorshape([2, 3]) which means, 2 lists, and each list has 3 elements
*** Change Shape
is possible to change shape as long as the number of elements corresponds to the current shape and the desired one

tensor1 = tf.ones([1,2,3])  # tf.ones() creates a shape [1,2,3] tensor full of ones
tensor2 = tf.reshape(tensor1, [2,3,1])  # reshape existing data to shape [2,3,1]
tensor3 = tf.reshape(tensor2, [3, -1])  # -1 tells the tensor to calculate the size of the dimension in that place
                                        # this will reshape the tensor to [3,3]
                                                                             
# The numer of elements in the reshaped tensor MUST match the number in the original

** Functions
tf.ones([shape,shape,...])
tf.zeros([shape,shape,...])
* Angular
start here: https://angular.io/tutorial
curso vence sep 30!!: https://courses.edx.org/courses/course-v1:Microsoft+DEV314x+1T2019a/course/
ecommerce fast: https://www.youtube.com/watch?v=gLa2LxMdAPs
ecommerce: https://www.youtube.com/watch?v=9K15zC0gN2I
best ecommerce: https://medium.com/javascript-in-plain-english/how-to-create-an-app-using-angular-and-firebase-part-1-debb80f928ad
* CSS
curso: https://courses.edx.org/courses/course-v1:W3Cx+CSS.0x+3T2018/course/
* React 
ecommerce: https://www.youtube.com/watch?v=wPQ1-33teR4
npx create-react-app
** react elements
+ theres html  like syntax (jsx)
const element = (
   <h1 className="greetings">
      hello, world!
   </h1>
);
gets mapped to 
const element = React.createElement(
    'h1',
    {className: 'greeting'},
    'Hello, World'

** react Components

you always extend the component, always create a constructor and a render, and always export it,

class Menu extends Component {
  constructor(props) {
    super(props);

  }
  
  render() {
    return (
        //jsx
    );

  }
  export default Menu
** react router
yarn add react-router-dom

-- in app.js
import { BrowserRouter } from 'react-router-dom';
<BrowserRouter>
      <div className="App">
        <Main />
      </div>
    </BrowserRouter>
    
-- in mainComponent


    render() {
    const HomePage = () => {
      return (
        <Home
          dish={this.state.dishes.filter(dish => dish.featured)[0]}
          promotion={this.state.promotions.filter(promo => promo.featured)[0]}
          leader={this.state.leaders.filter(leader => leader.featured)[0]}
        />
      );
    };
    // can be { match , location , history }

    const DishWithId = ({ match }) => {
      return (
        <DishDetail
          dish={
            this.state.dishes.filter(dish => dish.id === parseInt(match.params.dishId, 10))[0]
          }
          comments={this.state.comments.filter(
            comment => comment.dishId === parseInt(match.params.dishId, 10)
          )}
        />
      );
    };

    return (
      <div>
        <Header />
        <Switch>
          <Route path="/home" component={HomePage} />
          <Route exact path="/menu" component={() => <Menu dishes={this.state.dishes}/>}/>
          <Route path="/menu/:dishId" component={DishWithId} />
          <Route exact path="/contactus" component={Contact} />
          <Redirect to="/home" />
        </Switch>
        <Footer />
      </div>
    );
  }

*** links
the link is in backticks, and it sends the parameter dish.id as a prop, and is recieved in mainComponent in <Route path="/menu/:dishId">


    <Card>
      <Link to={`/menu/${dish.id}`}>
        <CardImg width="100%" src={dish.image} alt={dish.name} />
        <CardImgOverlay>
          <CardTitle>{dish.name}</CardTitle>
        </CardImgOverlay>
      </Link>
    </Card>

* Falcon
    https://www.alibabacloud.com/blog/building-very-fast-app-backends-with-falcon-web-framework-on-pypy_594282

* Docker-Compose
    https://gist.github.com/emmettna/b78f54a6683b06a2a2da21db7580a8d6
    https://www.youtube.com/watch?v=dVEjSmKFUVI
* Javascript
* PHP
* Nodejs
** --dev-save
it creates/appends the package to devdependencies in package.json
* Rust
** docs
rustup doc
** compile
rustc filename
** create project
cargo new name_app --bin
** unit tests
cargo test

to create a test:

#[test]
fn add() {

    assert_eq!(2+2, 4);
}

** project docs
cargo doc --open

** iterators
have defined functions and work like this
(0..10).sum

** match (same as case)

the underscore _ means anything else

match variable {

    0=>0,
    1=>1,
    _=> final,

}
** loops
there are for and while,

there are also loop, which can be used in expressions like this:

    let mut result = 1;
    result = loop {
        result += 1;
        if result == 10 {
            break result * 2
        }
    };
    /// result = 20

* awk
make colon be treated as a space

    awk -F: '{print $1}' /etc/group | head -4

* pdfgrep
it has most of the same settings as grep, it uses regex
-- means end of options similar to grep -e
so pdfgrep -- -v
insensitive
pdfgrep -i
* sed
** Backreferences
is better to use sed -r because it groups with () instead of \( \) 
which means you can use normal parenthesis like \( \) 

capture the entire line with &

    seq 15 | sed 's/.*/& sucks/'


    
