
* Machine Learning
** Types of machine learning
*** Supervised
training: when you have data and you know the output
*** Unsupervised
training: when you have data but no output (group data in clusters)
*** Reinforcement
when you give positive points to something that gets you closer to your goal/flag
** Fundamental Algorithms
*** Linear Regression
*** Classification
*** Clustering
*** Hidden Markov Models


* Tensorflow
** Main components
*** Graphs
an equation definition
*** Sessions
Executes certain parts of the graph
** Tensor
generalization of vectors and matrixes in potentially higher dimensions

Each tensor represents a partially defined computation that will eventually produce a value, which means that
tensors can be executed and you can get results from them
*** Types of Tensors
all are immutable except variables
+ Variables
+ Constants
+ Placeholder
+ SparseTensor
*** Evaluating Tensors/Getting value of a tensor
to get the value of a Tensor you need to create a session, like this

with tf.Session() as sess: # creates a session using the default graph
    name_of_my_tensor.eval()  

*** Rank/Degree
the deepest level of a nested list

+ Rank 1
    rank1_tensor = tf.Variable(["Test"], tf.string) 
+ Rank 2
    rank2_tensor = tf.Variable([["test", "ok"], ["test", "yes"]], tf.string)
    
tf.rank(rank2_tensor)
<tf.Tensor: shape=(), dtype=int32, numpy=2>

the numpy=2 means is of rank 2
*** example
string = tf.Variable("this is a string", tf.string) 
number = tf.Variable(324, tf.int16)
floating = tf.Variable(3.567, tf.float64)
*** Shape
all tensors have the attribute .shape
represents the number of items that exist in each dimension

rank2_tensor = tf.Variable([["test", "ok", "hey"], ["test", "yes", "why"]], tf.string)
+ rank2_tensor.shape 

  Tensorshape([2, 3]) which means, 2 lists, and each list has 3 elements
*** Change Shape
is possible to change shape as long as the number of elements corresponds to the current shape and the desired one

tensor1 = tf.ones([1,2,3])  # tf.ones() creates a shape [1,2,3] tensor full of ones
tensor2 = tf.reshape(tensor1, [2,3,1])  # reshape existing data to shape [2,3,1]
tensor3 = tf.reshape(tensor2, [3, -1])  # -1 tells the tensor to calculate the size of the dimension in that place
                                        # this will reshape the tensor to [3,3]
                                                                             
# The numer of elements in the reshaped tensor MUST match the number in the original

** Functions
tf.ones([shape,shape,...])
tf.zeros([shape,shape,...])
* Angular
start here: https://angular.io/tutorial
curso vence sep 30!!: https://courses.edx.org/courses/course-v1:Microsoft+DEV314x+1T2019a/course/
ecommerce fast: https://www.youtube.com/watch?v=gLa2LxMdAPs
ecommerce: https://www.youtube.com/watch?v=9K15zC0gN2I
best ecommerce: https://medium.com/javascript-in-plain-english/how-to-create-an-app-using-angular-and-firebase-part-1-debb80f928ad
* CSS
curso: https://courses.edx.org/courses/course-v1:W3Cx+CSS.0x+3T2018/course/
* React 
ecommerce: https://www.youtube.com/watch?v=wPQ1-33teR4
npx create-react-app
** react elements
+ theres html  like syntax (jsx)
const element = (
   <h1 className="greetings">
      hello, world!
   </h1>
);
gets mapped to 
const element = React.createElement(
    'h1',
    {className: 'greeting'},
    'Hello, World'

** react Components

you always extend the component, always create a constructor and a render, and always export it,

class Menu extends Component {
  constructor(props) {
    super(props);

  }
  
  render() {
    return (
        //jsx
    );

  }
  export default Menu
** react router
yarn add react-router-dom

-- in app.js
import { BrowserRouter } from 'react-router-dom';
<BrowserRouter>
      <div className="App">
        <Main />
      </div>
    </BrowserRouter>
    
-- in mainComponent


    render() {
    const HomePage = () => {
      return (
        <Home
          dish={this.state.dishes.filter(dish => dish.featured)[0]}
          promotion={this.state.promotions.filter(promo => promo.featured)[0]}
          leader={this.state.leaders.filter(leader => leader.featured)[0]}
        />
      );
    };
    // can be { match , location , history }

    const DishWithId = ({ match }) => {
      return (
        <DishDetail
          dish={
            this.state.dishes.filter(dish => dish.id === parseInt(match.params.dishId, 10))[0]
          }
          comments={this.state.comments.filter(
            comment => comment.dishId === parseInt(match.params.dishId, 10)
          )}
        />
      );
    };

    return (
      <div>
        <Header />
        <Switch>
          <Route path="/home" component={HomePage} />
          <Route exact path="/menu" component={() => <Menu dishes={this.state.dishes}/>}/>
          <Route path="/menu/:dishId" component={DishWithId} />
          <Route exact path="/contactus" component={Contact} />
          <Redirect to="/home" />
        </Switch>
        <Footer />
      </div>
    );
  }

*** links
the link is in backticks, and it sends the parameter dish.id as a prop, and is recieved in mainComponent in <Route path="/menu/:dishId">


    <Card>
      <Link to={`/menu/${dish.id}`}>
        <CardImg width="100%" src={dish.image} alt={dish.name} />
        <CardImgOverlay>
          <CardTitle>{dish.name}</CardTitle>
        </CardImgOverlay>
      </Link>
    </Card>

* Falcon
    https://www.alibabacloud.com/blog/building-very-fast-app-backends-with-falcon-web-framework-on-pypy_594282

* Docker-Compose
    https://gist.github.com/emmettna/b78f54a6683b06a2a2da21db7580a8d6
    https://www.youtube.com/watch?v=dVEjSmKFUVI
* Javascript
* PHP
* Nodejs
** --dev-save
it creates/appends the package to devdependencies in package.json
* Rust
** docs
rustup doc
** compile
rustc filename
** create project
cargo new name_app --bin
** unit tests
cargo test

to create a test:

#[test]
fn add() {

    assert_eq!(2+2, 4);
}

** project docs
cargo doc --open

** iterators
have defined functions and work like this
(0..10).sum

** match (same as case)

the underscore _ means anything else

match variable {

    0=>0,
    1=>1,
    _=> final,

}
** loops
there are for and while,

there are also loop, which can be used in expressions like this:

    let mut result = 1;
    result = loop {
        result += 1;
        if result == 10 {
            break result * 2
        }
    };
    /// result = 20

* awk
make colon be treated as a space

    awk -F: '{print $1}' /etc/group | head -4

* pdfgrep
it has most of the same settings as grep, it uses regex
-- means end of options similar to grep -e
so pdfgrep -- -v
insensitive
pdfgrep -i
* sed
is better to use sed -r because it groups with () instead of \( \) 
which means you can use normal parenthesis like \( \) 

capture the entire line with &

    seq 15 | sed 's/.*/& sucks/'


